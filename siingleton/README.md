## 单例模式

### 1、饿汉式单例
   ##### 饿汉式单例：是在类加载时就立即初始化，并且创建单例对象，线程安全。
   - 优点：没有加任何的锁，执行效率高。
   - 缺点：类加载时就初始化，不管用不用都占用空间，浪费了内存
   
### 2、懒汉式单例
   #### 懒汉式单例：是在被外部类调用的时候内部类才会加载
   ####简单懒汉单例：使用了synchronized方法锁，保证了唯一实例，但是在高并发的情况下，效率会很低
   ####双重检查锁单例：使用了synchronized修饰代码块，保证了唯一实例，同时在方法内部阻塞，只要逻辑不是太复杂，在高并发的情况下，效率不会很低
   ####内部类单例：兼顾饿汉式的内存浪费，也兼顾 synchronized 性能问题。内部类一定是要在方法调用之前初始化，巧妙地避免了线程安全问题。

### 3、注册式单例
   - ### 枚举式单例
       #### 通过枚举来实现单例，通天枚举的特性可以规避反射和序列化带来的攻击
   - ### 容器式单例
       #### 通过容器管理实例，适用于创建实例非常多的情况，便于管理；
       #### 但是是线程非安全的
       
### 4、ThreadLocal线程单例
   #### ThreadLocal将所有的对象全部放在 ThreadLocalMap 中，为每个线程都提供一个对象，实际上是以空间换时间来实现线程间隔离的。
       
       
   
   
## 破坏单例模式的方式和解决办法
   ###使用反射的方式：通过反射强制调用类的私有构造方法，破坏单例模式的唯一实例；通过在构造方法里增加运行时异常来解决；
   ###反序列化的方式：通过io反序列方式构建实例，通过在类中增加readResolve()方法来解决
   